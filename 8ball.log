Initial entry: 19-AUG-2016

Writing a PDP-8 emulator is amazingly fun. I've known about the PDP-8
for many years, I've even had the oportunity to se a working one and
help write small programs for a specific purpose. But that was a few
years ago and I had forgotten most of it when I started 8ball.

Writing the bulk of the CPU and Serial interface emulation took no
more than a few nights with a few hours of coding and studying
[1]Douglas W. Jones "A Programmer's Reference Manual", which is a
greate resource for anyone wanting to learn about the PDP-8 internals.

So, 10 hours _maximum_ to have a basic CPU implementation. I probably
spent an equal amount of time, if not more, getting the terminal
handling right and figuring out how to read paper tape images from
file.

The first test was a simple hello world program. <TODO date>

But the first hurdle was really getting the RIM loader to work. I was
eager to get the MAINDEC cpu diagnostics running so I figured I would
input a BIN-loader by hand but the first BIN-loader image I found was
somehow not correct or I made to many misstakes entering it. I figured
it was too many variables and took a step back and entered the RIM
loader manually, loaded the binloader and fixed a few bugs along the
way.

Initially I debugged the emulator using gdb, but it quickly became
cumbersome to jump between a running emulator, the emulator console
and the gdb console so I implemented a single step command to the
console, much like the single step switch available on a real
PDP-8/e. And I also implemented a simple dissasembler so that I can
examine memory and quickly compare it to code listings and see what is
going. I expanded the dissasembly during the course of running the
first MAINDEC.

When I finally got all the bits together to load the CPU instruction
test it took only a day or so to iron out the last basic instruction
set bugs and have the first MAINDEC pass! Testdriven development is
great!

Update: 29-AUG-2016

I got the next MAINDEC out of the pile 8E-D0BB which tests indirect
addressing, autoindexing and foremost the interrupt system. The memory
test passed with flying colors so I had wrap my head arround PDP-8
interrupts and make a rudimentary implementation. I quickly ironed out
the basics but got stuck a while with ION and the delay with turning
the interrupt system on. Doug's otherwise excellent manual is subtly
wrong in his description of ION. He states that the interrupt system
is turned on after the instrucion following ION when in fact it's
turned on after the PC is incremented during the following instruction
FETCH cycle. This probably only matters in the ION IOF sequence that
of course is present in the D0BB test suite :)

Then I struggled a while figuring out when the interrupt request line
should be turned off. I'm still not sure I got the details right, but
the test are passing now. Doug's description of RTF misses the fact
that RTF always turns on interrupts, regardless of the flag in AC.

D0BB also revealed some other smaller bugs and I of course added
dissasembly of the new instructions as well as improved emulation of
the TTY (it's 7 bit, not 8).

Surprisingly my DCA implementation cleared the LINC bit, which it
shouldn't, but no test caught it thus far.

Update: 19-SEP-2016

After passing the first MAINDECs I figured I should make an automatic
test suite so that I could quickly run all MAINDECs again. Adding some
sort of scripting language to the emulator to control loading and
running of papertapes felt like a big job at this point. Instead I
implemented a way of saving and restoring emulator state, something I
wanted anyway to emulate core memory. This way I can load a MAINDEC,
set up the PC and switch register (SR) and then save the state to a
file from which the emulator could be resumed. I added command line
parsing so that a state file could be specified at start. Most
MAINDECs executes a HLT instruction on failure and prints a control
character (BEL, an audible *ding* on a real TTY) on a successful test
round. Noticing this pattern I added one option to exit the emulator
on a HLT instruction and another option to exit when the PC reached a
given address. A test script can then differentiate between a failed
and successful test.

I added the MAINDECs I had already run to a test script and
reintroduced a few bugs to test the tests. It worked nicely and I
added more instruction test MAINDECs to the suite. Quite booring and
tedious since all of them worked :-).

I have more instruction tests to add, but I took a break from it and
started implementing KM8E support. It is the memory management and
time sharing option that allows for up to 32kW of memory and multiple
user processes. So far I have basic support for memory management but
have not passed all tests yet.

I think that I have begun to reach the end of what Dougs excellent
programmers manual can give. The KM8E description is lacking in some
details, but I've found that reading DEC manuals is now a lot easier
thanks to the soft introduction given by Doug. I will still have use
of his manual if I decide to implement support for the high speed
paper tape reader and punch. As well as the VC8E point plot display of
which there is very little information to be find in other places.

A side note, I've looked for information regarding the VC8E in other
places but only found what is written about it in the Small Computer
Handbook from 1973 [2]. That description is quite superficial and
strikingly similar to Dougs description. I later read the source code
to the point plot display in simh, written by Phil Budne [3], and it
refers to Dougs PDP-8 emulator. I didn't realize that Doug had written
an emulator, but he has and it's available on his homepage [4]. In
_that_ code Doug seems to lament that there is little information the
VC8E availble other than what is in the hanbook, which explains the
similarities in technical detail.

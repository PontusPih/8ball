Initial entry: 19-AUG-2016

Writing a PDP-8 emulator is amazingly fun. I've known about the PDP-8
for many years, I've even had the oportunity to se a working one and
help write small programs for a specific purpose. But that was a few
years ago and I had forgotten most of it when I started 8ball.

Writing the bulk of the CPU and Serial interface emulation took no
more than a few nights with a few hours of coding and studying
[1]Douglas W. Jones "A Programmer's Reference Manual", which is a
greate resource for anyone wanting to learn about the PDP-8 internals.

So, 10 hours _maximum_ to have a basic CPU implementation. I probably
spent an equal amount of time, if not more, getting the terminal
handling right and figuring out how to read paper tape images from
file.

The first test was a simple hello world program. Probably ran
successfully for the first time arround July 19.

But the first hurdle was really getting the RIM loader to work. I was
eager to get the MAINDEC cpu diagnostics running so I figured I would
input a BIN-loader by hand but the first BIN-loader image I found was
somehow not correct or I made to many misstakes entering it. I figured
it was too many variables and took a step back and entered the RIM
loader manually, loaded the binloader and fixed a few bugs along the
way.

Initially I debugged the emulator using gdb, but it quickly became
cumbersome to jump between a running emulator, the emulator console
and the gdb console so I implemented a single step command to the
console, much like the single step switch available on a real
PDP-8/e. And I also implemented a simple dissasembler so that I can
examine memory and quickly compare it to code listings and see what is
going. I expanded the dissasembly during the course of running the
first MAINDEC.

When I finally got all the bits together to load the CPU instruction
test it took only a day or so to iron out the last basic instruction
set bugs and have the first MAINDEC pass! Testdriven development is
great!

Update: 29-AUG-2016

I got the next MAINDEC out of the pile 8E-D0BB which tests indirect
addressing, autoindexing and foremost the interrupt system. The memory
test passed with flying colors so I had wrap my head arround PDP-8
interrupts and make a rudimentary implementation. I quickly ironed out
the basics but got stuck a while with ION and the delay with turning
the interrupt system on. Doug's otherwise excellent manual is subtly
wrong in his description of ION. He states that the interrupt system
is turned on after the instrucion following ION when in fact it's
turned on after the PC is incremented during the following instruction
FETCH cycle. This probably only matters in the ION IOF sequence that
of course is present in the D0BB test suite :)

Then I struggled a while figuring out when the interrupt request line
should be turned off. I'm still not sure I got the details right, but
the test are passing now. Doug's description of RTF misses the fact
that RTF always turns on interrupts, regardless of the flag in AC.

D0BB also revealed some other smaller bugs and I of course added
dissasembly of the new instructions as well as improved emulation of
the TTY (it's 7 bit, not 8).

Surprisingly my DCA implementation cleared the LINC bit, which it
shouldn't, but no test caught it thus far.

Update: 19-SEP-2016

After passing the first MAINDECs I figured I should make an automatic
test suite so that I could quickly run all MAINDECs again. Adding some
sort of scripting language to the emulator to control loading and
running of papertapes felt like a big job at this point. Instead I
implemented a way of saving and restoring emulator state, something I
wanted anyway to emulate core memory. This way I can load a MAINDEC,
set up the PC and switch register (SR) and then save the state to a
file from which the emulator could be resumed. I added command line
parsing so that a state file could be specified at start. Most
MAINDECs executes a HLT instruction on failure and prints a control
character (BEL, an audible *ding* on a real TTY) on a successful test
round. Noticing this pattern I added one option to exit the emulator
on a HLT instruction and another option to exit when the PC reached a
given address. A test script can then differentiate between a failed
and successful test.

I added the MAINDECs I had already run to a test script and
reintroduced a few bugs to test the tests. It worked nicely and I
added more instruction test MAINDECs to the suite. Quite booring and
tedious since all of them worked :-).

I have more instruction tests to add, but I took a break from it and
started implementing KM8E support. It is the memory management and
time sharing option that allows for up to 32kW of memory and multiple
user processes. So far I have basic support for memory management but
have not passed all tests yet.

I think that I have begun to reach the end of what Dougs excellent
programmers manual can give. The KM8E description is lacking in some
details, but I've found that reading DEC manuals is now a lot easier
thanks to the soft introduction given by Doug. I will still have use
of his manual if I decide to implement support for the high speed
paper tape reader and punch. As well as the VC8E point plot display of
which there is very little information to be find in other places.

A side note, I've looked for information regarding the VC8E in other
places but only found what is written about it in the Small Computer
Handbook from 1973 [2]. That description is quite superficial and
strikingly similar to Dougs description. I later read the source code
to the point plot display in simh, written by Phil Budne [3], and it
refers to Dougs PDP-8 emulator. I didn't realize that Doug had written
an emulator, but he has and it's available on his homepage [4]. In
_that_ code Doug seems to lament that there is little information the
VC8E availble other than what is in the hanbook, which explains the
similarities in technical detail.

Update 23-SEP-2016

Yesterday I got the emulation of the memory extension part of the KM8E
down and the emulator passes that part of the tests. It's clear that
Dougs manual is downright wrong when it comes to GTF and RTF. However,
the manuals and handbooks aren't that good either. The 1976 PDP8/a
Minicomputer Handbook is even wrong on page 6-36, it misses some bits
that are restored to AC when executing RTF. 1973 is slightly better on
page 5-14.

I finaly got it figured out by reading the 1976 hanbook, the 1973
Small computer handbook, the KM8E option manual, talking with BQT and
finally checking the SIMH code. Reading SIMH code is something I
wanted to avoid for the learning experience so it was a bit of a
defeat.

So, for posterity:

GTF will save the LINK bit in AC bit 0, the interrupt request flag in
AC bit 2, ION flag in AC bit 4 and the whole SF register in AC bit
5-11.

RTF will immediately set ION and INHIB, no delay. It restores the LINK
bit from AC bit 0, the IB from AC bit 6-8 and DF from AC bit 9-11. The
following JMP or JMS will restore IF exactly the same way as after a
CIF.

Oh yes, the EAE bit GT and KM8E U bit is also saved and restored, but
I haven't implemented and tested that yet :)

Update 29-SEP-2016

Horray, the emulator finally passes the Time Share part of the
KM8E. It was just as frustrating as implementing the MMU. For
instance, both CUF and SUF will raise the interrupt inhibit flag but
the documentation is vague on that detail. Also not obvious is that UF
_and_ UB is set to zero on an interrupt.

Worth noting is that GTF doesn't put the UF in AC but the status of
the user interrupt bit. Interrupts also saves the user interrupt bit
in SF, not UF itself. RTF and RMF restores UB, not UF, analog to IB
being restored. RMF must also inhibit interrupts.

Again I felt I had to resort to SIMH source code which was a bit
dissapointing.

A good thing that came of the bout with this side of the PDP-8
architecture is that I felt the need to implement breakpoints which
aided greatly in debugging the interrupts and CIFs happening at the
same time. I also implemented an instruction trace so I could follow
program flow before a breakpoint hit. With those two tools it was much
easier to figure out errors.

One bug I would have been much harder to find without the program
trace. I noticed when doing test 16 of D1HA that one instruction
suddenly changed in memory!?! It turns out that i calculated the
"operand address" for _every_ instruction even instructions that
doesn't have an operand, like IOT instructions. Now, if the IOT
instruction has a device number which sets the indirect bit and an
address in the autoincrement index memory range.. well, that index
would be incrementing. And test 16 has program instructions there
which got incremented and became something else.

After fixing this, lots of test failed in my own test suite due to the
post test memory state changed for addresses between 010 and 017 :)

Update 21-OCT-2016

Theres been some time since I had time to work properly on the
emulator. I decided after the battle with memory management and time
share that it was time to tidy up the code and get some of the TODOs
I'd left behind done.

Most was small things related to how the console was handled. Console
command history is now saved between sessions. The IF can now be set
from the console. Ctrl+C when in the console quits the
emulator. Breakpoints can be listed and deleted all at once.

Since I have been using simh a bit I felt the need to improve my
console a bit so I've completely rewritten the command line parser to
make it easier to understand and extend. A bonus was that error
handling became easier and the user now gets somewhat helpful error
messages. Added unit tests for the console.

Yesterday I visited Update for the monthly "sweatshop" where we gather
and work on whatever project we have. It's also an oportunity to show
of. Since I knew some would be interrested in my emulator I decided to
search for a good demo. I recently stumbled upon Jean-Claude Wipplers
embedded emulator [5] and he showed a nice little FOCAL demo so I
decided on that.

However, running FOCAL resulted in a prompt and interrupt loop. It did
not respond to input at all. After an hour or so of debugging I
realized that the emulator didn't clear the interrupt request when the
tty keyboard flag is cleared. I'm quite surprised no MAINDEC caught
this, on the other hand non of them are interactive. There are still
some issues with the TTY emulation that I'm trying to iron out, for
instance the keyboard and printer probably need separate interrupt
flags.

But I got FOCAL running and gave a nice demo. While at Update I
flipped through a paper copy of an earlier version of "The Small
Computer Handbook" which describes the 8/i and 8/l. And I must say it
had a much clearer and detailed description of the instruction
set. Sadly the /i and /l doesn't implement the GTF, RTF, and CAF that
I've had troubles with. I will however crossreference with this book
when I implement EAE and other peripherals.

Update 20-MAR-2020

Yikes, I haven't updated this log in four years! But things have
happened in that time. Mostly I have focused on splitting the code for
handling the CPU and handling the console input into different
process. The idea being that the CPU should be able to run on a
microcontroller and the console being handled on a different computer
with a serial connection to the microcontroller.

After that I have taken a break and implemented a game for the PDP-8
in PAL-8 assembly. Check it out: https://github.com/PontusPih/TINT8

That was most of 2017, in 2018 I didn't do much PDP-8 related at all.
In 2019 I gave a presentation at Update where I reimplemented a basic
non-expanded PDP-8 cpu in front of a live audience. It was a lot of
fun. Although it took much longer than anticipated, close to two hours.

During the fall of 2019 I've helped out a collegue who is implementing
his own PDP-8 emulator. It's been a lot of fun and the urge to hack
away at my own emulator has come back :)

First, some small changes:

Previously the code used "cur" as variable name for the current
instruction. In the real PDP-8 hardware it is stored in the memory
buffer, MB, which all documentation refers to. To avoid confusion I
renamed the variable to plain "mb".

Also the code used "addr" as variable name for the current memory
address being referenced by instructions. The real hardware uses the
Central Processor Memory Address, CPMA, so "addr" is renamed to
"cpma".

I want to restructure the code a bit to make sections reflect the
"time states" in which a PDP-8 processor executes. There is no real
purpose other than being one step closer to a hardware implementation.


[1] http://homepage.cs.uiowa.edu/~jones/pdp8/man/index.html
[2] http://bitsavers.informatik.uni-stuttgart.de/pdf/dec/pdp8/handbooks/Small_Computer_Handbook_1973.pdf
[3] http://www.ultimate.com/phil/xy/
[4] http://homepage.cs.uiowa.edu/~jones/pdp8/emulator.txt.Z
[5] http://jeelabs.org/2016/10/stm32f103-emulating-a-pdp-8/
Initial entry: 19-AUG-2016

Writing a PDP-8 emulator is amazingly fun. I've known about the PDP-8
for many years, I've even had the oportunity to se a working one and
help write small programs for a specific purpose. But that was a few
years ago and I had forgotten most of it when I started 8ball.

Writing the bulk of the CPU and Serial interface emulation took no
more than a few nights with a few hours of coding and studying
[1]Douglas W. Jones "A Programmer's Reference Manual", which is a
greate resource for anyone wanting to learn about the PDP-8 internals.

So, 10 hours _maximum_ to have a basic CPU implementation. I probably
spent an equal amount of time, if not more, getting the terminal
handling right and figuring out how to read paper tape images from
file.

The first test was a simple hello world program. Probably ran
successfully for the first time arround July 19.

But the first hurdle was really getting the RIM loader to work. I was
eager to get the MAINDEC cpu diagnostics running so I figured I would
input a BIN-loader by hand but the first BIN-loader image I found was
somehow not correct or I made to many misstakes entering it. I figured
it was too many variables and took a step back and entered the RIM
loader manually, loaded the binloader and fixed a few bugs along the
way.

Initially I debugged the emulator using gdb, but it quickly became
cumbersome to jump between a running emulator, the emulator console
and the gdb console so I implemented a single step command to the
console, much like the single step switch available on a real
PDP-8/e. And I also implemented a simple dissasembler so that I can
examine memory and quickly compare it to code listings and see what is
going. I expanded the dissasembly during the course of running the
first MAINDEC.

When I finally got all the bits together to load the CPU instruction
test it took only a day or so to iron out the last basic instruction
set bugs and have the first MAINDEC pass! Testdriven development is
great!

Update: 29-AUG-2016

I got the next MAINDEC out of the pile 8E-D0BB which tests indirect
addressing, autoindexing and foremost the interrupt system. The memory
test passed with flying colors so I had wrap my head arround PDP-8
interrupts and make a rudimentary implementation. I quickly ironed out
the basics but got stuck a while with ION and the delay with turning
the interrupt system on. Doug's otherwise excellent manual is subtly
wrong in his description of ION. He states that the interrupt system
is turned on after the instrucion following ION when in fact it's
turned on after the PC is incremented during the following instruction
FETCH cycle. This probably only matters in the ION IOF sequence that
of course is present in the D0BB test suite :)

Then I struggled a while figuring out when the interrupt request line
should be turned off. I'm still not sure I got the details right, but
the test are passing now. Doug's description of RTF misses the fact
that RTF always turns on interrupts, regardless of the flag in AC.

D0BB also revealed some other smaller bugs and I of course added
dissasembly of the new instructions as well as improved emulation of
the TTY (it's 7 bit, not 8).

Surprisingly my DCA implementation cleared the LINC bit, which it
shouldn't, but no test caught it thus far.

Update: 19-SEP-2016

After passing the first MAINDECs I figured I should make an automatic
test suite so that I could quickly run all MAINDECs again. Adding some
sort of scripting language to the emulator to control loading and
running of papertapes felt like a big job at this point. Instead I
implemented a way of saving and restoring emulator state, something I
wanted anyway to emulate core memory. This way I can load a MAINDEC,
set up the PC and switch register (SR) and then save the state to a
file from which the emulator could be resumed. I added command line
parsing so that a state file could be specified at start. Most
MAINDECs executes a HLT instruction on failure and prints a control
character (BEL, an audible *ding* on a real TTY) on a successful test
round. Noticing this pattern I added one option to exit the emulator
on a HLT instruction and another option to exit when the PC reached a
given address. A test script can then differentiate between a failed
and successful test.

I added the MAINDECs I had already run to a test script and
reintroduced a few bugs to test the tests. It worked nicely and I
added more instruction test MAINDECs to the suite. Quite booring and
tedious since all of them worked :-).

I have more instruction tests to add, but I took a break from it and
started implementing KM8E support. It is the memory management and
time sharing option that allows for up to 32kW of memory and multiple
user processes. So far I have basic support for memory management but
have not passed all tests yet.

I think that I have begun to reach the end of what Dougs excellent
programmers manual can give. The KM8E description is lacking in some
details, but I've found that reading DEC manuals is now a lot easier
thanks to the soft introduction given by Doug. I will still have use
of his manual if I decide to implement support for the high speed
paper tape reader and punch. As well as the VC8E point plot display of
which there is very little information to be find in other places.

A side note, I've looked for information regarding the VC8E in other
places but only found what is written about it in the Small Computer
Handbook from 1973 [2]. That description is quite superficial and
strikingly similar to Dougs description. I later read the source code
to the point plot display in simh, written by Phil Budne [3], and it
refers to Dougs PDP-8 emulator. I didn't realize that Doug had written
an emulator, but he has and it's available on his homepage [4]. In
_that_ code Doug seems to lament that there is little information the
VC8E availble other than what is in the hanbook, which explains the
similarities in technical detail.

Update 23-SEP-2016

Yesterday I got the emulation of the memory extension part of the KM8E
down and the emulator passes that part of the tests. It's clear that
Dougs manual is downright wrong when it comes to GTF and RTF. However,
the manuals and handbooks aren't that good either. The 1976 PDP8/a
Minicomputer Handbook is even wrong on page 6-36, it misses some bits
that are restored to AC when executing RTF. 1973 is slightly better on
page 5-14.

I finaly got it figured out by reading the 1976 hanbook, the 1973
Small computer handbook, the KM8E option manual, talking with BQT and
finally checking the SIMH code. Reading SIMH code is something I
wanted to avoid for the learning experience so it was a bit of a
defeat.

So, for posterity:

GTF will save the LINK bit in AC bit 0, the interrupt request flag in
AC bit 2, ION flag in AC bit 4 and the whole SF register in AC bit
5-11.

RTF will immediately set ION and INHIB, no delay. It restores the LINK
bit from AC bit 0, the IB from AC bit 6-8 and DF from AC bit 9-11. The
following JMP or JMS will restore IF exactly the same way as after a
CIF.

Oh yes, the EAE bit GT and KM8E U bit is also saved and restored, but
I haven't implemented and tested that yet :)

Update 29-SEP-2016

Horray, the emulator finally passes the Time Share part of the
KM8E. It was just as frustrating as implementing the MMU. For
instance, both CUF and SUF will raise the interrupt inhibit flag but
the documentation is vague on that detail. Also not obvious is that UF
_and_ UB is set to zero on an interrupt.

Worth noting is that GTF doesn't put the UF in AC but the status of
the user interrupt bit. Interrupts also saves the user interrupt bit
in SF, not UF itself. RTF and RMF restores UB, not UF, analog to IB
being restored. RMF must also inhibit interrupts.

Again I felt I had to resort to SIMH source code which was a bit
dissapointing.

A good thing that came of the bout with this side of the PDP-8
architecture is that I felt the need to implement breakpoints which
aided greatly in debugging the interrupts and CIFs happening at the
same time. I also implemented an instruction trace so I could follow
program flow before a breakpoint hit. With those two tools it was much
easier to figure out errors.

One bug I would have been much harder to find without the program
trace. I noticed when doing test 16 of D1HA that one instruction
suddenly changed in memory!?! It turns out that i calculated the
"operand address" for _every_ instruction even instructions that
doesn't have an operand, like IOT instructions. Now, if the IOT
instruction has a device number which sets the indirect bit and an
address in the autoincrement index memory range.. well, that index
would be incrementing. And test 16 has program instructions there
which got incremented and became something else.

After fixing this, lots of test failed in my own test suite due to the
post test memory state changed for addresses between 010 and 017 :)

Update 21-OCT-2016

Theres been some time since I had time to work properly on the
emulator. I decided after the battle with memory management and time
share that it was time to tidy up the code and get some of the TODOs
I'd left behind done.

Most was small things related to how the console was handled. Console
command history is now saved between sessions. The IF can now be set
from the console. Ctrl+C when in the console quits the
emulator. Breakpoints can be listed and deleted all at once.

Since I have been using simh a bit I felt the need to improve my
console a bit so I've completely rewritten the command line parser to
make it easier to understand and extend. A bonus was that error
handling became easier and the user now gets somewhat helpful error
messages. Added unit tests for the console.

Yesterday I visited Update for the monthly "sweatshop" where we gather
and work on whatever project we have. It's also an oportunity to show
of. Since I knew some would be interrested in my emulator I decided to
search for a good demo. I recently stumbled upon Jean-Claude Wipplers
embedded emulator [5] and he showed a nice little FOCAL demo so I
decided on that.

However, running FOCAL resulted in a prompt and interrupt loop. It did
not respond to input at all. After an hour or so of debugging I
realized that the emulator didn't clear the interrupt request when the
tty keyboard flag is cleared. I'm quite surprised no MAINDEC caught
this, on the other hand non of them are interactive. There are still
some issues with the TTY emulation that I'm trying to iron out, for
instance the keyboard and printer probably need separate interrupt
flags.

But I got FOCAL running and gave a nice demo. While at Update I
flipped through a paper copy of an earlier version of "The Small
Computer Handbook" which describes the 8/i and 8/l. And I must say it
had a much clearer and detailed description of the instruction
set. Sadly the /i and /l doesn't implement the GTF, RTF, and CAF that
I've had troubles with. I will however crossreference with this book
when I implement EAE and other peripherals.

Update 20-MAR-2020

Yikes, I haven't updated this log in four years! But things have
happened in that time. Mostly I have focused on splitting the code for
handling the CPU and handling the console input into different
process. The idea being that the CPU should be able to run on a
microcontroller and the console being handled on a different computer
with a serial connection to the microcontroller.

After that I have taken a break and implemented a game for the PDP-8
in PAL-8 assembly. Check it out: https://github.com/PontusPih/TINT8

That was most of 2017, in 2018 I didn't do much PDP-8 related at all.
In 2019 I gave a presentation at Update where I reimplemented a basic
non-expanded PDP-8 cpu in front of a live audience. It was a lot of
fun. Although it took much longer than anticipated, close to two hours.

During the fall of 2019 I've helped out a collegue who is implementing
his own PDP-8 emulator. It's been a lot of fun and the urge to hack
away at my own emulator has come back :)

First, some small changes:

Previously the code used "cur" as variable name for the current
instruction. In the real PDP-8 hardware it is stored in the memory
buffer, MB, which all documentation refers to. To avoid confusion I
renamed the variable to plain "mb".

Also the code used "addr" as variable name for the current memory
address being referenced by instructions. The real hardware uses the
Central Processor Memory Address, CPMA, so "addr" is renamed to
"cpma".

I want to restructure the code a bit to make sections reflect the
"time states" in which a PDP-8 processor executes. There is no real
purpose other than being one step closer to a hardware implementation.

Update 24-MAR-2020

I've started implementing RX8 support! It is still tremendously fun to
work with MAINDEC tests again. This time DIRXA, the diagnostics for
RX8 and RX01. Not entirely obvious how to run the tests. But it is
important to set a value to the first two questions. The first
question decides if the controller and drives is tested (0000) or not
(7000). The second question lets you set 0400 which halts on error.

Already I was helped by test T2 to get the flags handling right.

Update 12-APR-2020

Phew, this test program is tricky to get right. I want to test all
relevant combinations and have noted them in device.test

Comments on row 2749 through 2757 in DIRXA is probably wrong, the
DRIVE READY bit in the status register will be cleared by the
F_READ_SECT and F_WRT_SECT functions. At least if the test _code_ is
to be believed.

Update 14-APR-2020

Last bug fixed! RX emulator now passes Interface, Controller AND Drive
maindecs! Next I should look at DIRXB if it makes sense to run in an
emulator.

Then I must look at reading an actual floppy image.

Update 3-SEP-2020

I got more or less challenged into getting OS/8 running using an RX
floppy. So, I added code to load an image into memory and took a
bootloader from SIMH. A nearly identical loader is listed in the OS8
Handbook Update from 1977 [6]. I did not get far, the loader only put
garbage into memory. I realised after a while that the loader looked
for drive 1 and I had mounted the floppy in drive 0. Easliy fixed but
there was still only garbage loaded. But I had a hunch from before
that the bits in the floppy images was packed differently from what I
had assumed. This turned out to be the case and some fiddling with the
unpacking code I got good data in. However, OS/8 would not load.

Update 4-SEP-2020

I went back and ran the MAINDECS and they promptly failed. The data
written was not read back correctly. A bitpacked sector is loaded into
the sector buffer and is only unpacked when the controller reads the
data from the drive. I had forgotten that I must then pack the bits
when they are written to the sector buffer in order for the MAINDECS
to read the back. I fixed that. However, OS/8 would not load.

Update 5-SEP-2020

Unable to let a problem like this rest I stayed up late again and
followed the code flow in both SIMH and 8ball. And I could verify that
8ball could load the top pages in field 0 and 1 correctly but would
halt much earlier than SIMH. No luck understanding why..

Update 6-SEP-2020

Ok, progress! I improved the output from code tracing in 8ball and
carefully followed the execution of OS/8's bootstrap. I could now see
that the boot loader tries to read from track 1 and sector 0211! Well,
the larges allowed sector is 032 so my RX emulator will raise the
error flag which OS/8 checks and halts.

I looked at SIMH(cheating again!) and it turns out that I assumed the
RXTA and RXSA could be 12 bit as long as I checked the boundaries,
believing that the software was responsible for staying within the
bounds. BUT, the RXTA and RXSA is documented as being 8 bit wide(in
the RX01 maintenance manual[7]). So, will it be possible for software
to ask for sector 0211? No, 0211 fit well in 8 bits, something is
wonky?!

SIMH uses a bitmask with the lowest seven bits set. And there is a
comment next to it which says "cf Jones!!". So I checked with Dave
Jones page on the RX01. And he notes that RXTA is 8 bits but RXSA is
only 7! Seems like he is right and the RX01 maintenance manual is
wrong. With this information the loader gets a bit further. However,
OS/8 would not load!

Update 6-SEP-2020 (Late night addendum)

Following the boot sequence of OS/8 I could see that it loads the NOOP
command of the RX01. After that it would just hang waiting for the
done flag. Apparently the NOOP command is not quite a NO OPeration, it
raises the done flag when it is done doing nothing. OS8 finally boots!

Update 25-APR-2021

After doing my talk at Update once again, which was well received by
the way, I decided to work out the kinks in the serial communcations
layer. Now it is as good as it gets. So while I remember, here is how
it is meant to work.

At the bottom there is "serial_com.c" which can send "frames" that
start with '{' and end with '}'. Characters with special meaning
inside a frame is escaped with '~' (itself a special character). There
is no checksums, sequence number or size information in a frame. It's
all very basic.

The special "console" character '.' will terminate transfer of a frame
and the reported frame size is -1. This enables one side to abort an
ongoing transfer and reset communications.

The "frontend.c" and "backend.c" code has a simple protocol that is
sent as frames. The backend should be started first. The frontend
connects to it by sending one "console" character and the backend
should reply with one "console" character in return:

                   frontend      backend
(in console mode)     |           |
                      |---- . --->|
                                  | (goes to console mode)
                      |<--- . ----|
                      |           
                      v

Now, both frontend and backend should be in "console" mode where the
frontend reads input from the user and can issue commands to the
backend.

If the frontend wants to start the emulator in the backend it sends an
'R' within a frame. The backend will start running and will not reply.

                   frontend       backend
(in console mode)     |              
                      |--- { R } --->|
                                     | (starts running)
                                     v

When in running mode:

If the backend needs to do I/O it will send a request for input or
deliver output to the frontend. Output for the TTY is sent as a frame
with the letter 'T' (for TTY), 'W' (for write), and a byte 'c' for
output. The frontend will send 'C' back to let the emulator continue.

                   frontend       backend
                                     | (running)                       
                      |<-- { TWc } --| (sends TTY output)
(performs output)     |		      
                      |--- { C } --->|
                                     | (continues running)
                                     v

The backend will periodically ask the frontend for input from the TTY
by sending TR. The frontend will reply with 'C' if there is no
character to read. Otherwise it sends 'T' and the character 'c'. Then
the backend will acknowledge that the character was received and the
frontend will send 'C' for continue.

                   frontend       backend
                                     | (running)                       
                      |<-- { TR } ---| (asks for input)
(Finds no input)      |		      
                      |--- { C } --->|
                                     | (continues running)
                                     v

                   frontend       backend
                                     | (running)                       
                      |<-- { TR } ---| (asks for input)
(Finds input)         |		      
                      |--- { Tc } -->|
		                     |
                      |<-- { A } ----| (Acknowledges input)
		      |
                      |--- { C } --->|		      
                                     | (continues running)
                                     v

To abort the running mode the user can press CTRL+C and send a unix
signal to the frontend process. The signal handler will send a single
console special byte: '.'

In order for the backend to finish any I/O request there is a bit of
back and forth to settle in console mode. If the there is no I/O the
exchange is as follows.

While the backend runs it will periodically check for a console byte
using nonblocking I/O. It will reply with an 'I', to wake up the
frontend (which is hanging on read()). The frontend returns to console
mode.

                   frontend       backend          signal handler
                                       | (running)
                                       |                | (wakes up by signal)
                                       | <--- { . } --- | (sends byte, stops)
                                       | (Checks for console byte)
                      | <-- { I } ---- | (Sends 'I')
(in console mode)     |
    	    	      |
		      v

If the frontend was interacting with the backend to do I/O. It will be
more convoluted. First is the case when the frontend sends a '.' just
as the backend asks for I/O attention.

                   frontend       backend          signal handler
                                       | (running)
                                       |                | (wakes up by signal)
                                       | <--- { . } --- | (sends byte, stops)
                                       |
                      | <-- { I/O }--- | (has not read '.', sends I/O req)
(does I/O)            |
                      | --> { I/O }--> |
                                       | (Reads console byte)
(Expects 'A', get '.')| <---  .  ----- | (Replies with '.')
(Waits for 'A')                        | (Reads I/O, acks)
                      | <-- { A } ---- |
(Go to console mode)  |
		      |
		      v

If the front end has just finished IO:

                   frontend       backend          signal handler
                                       | (running)
                                       |
                      | <-- { I/O }--- | (sends I/O req)
(does I/O)            |
                      | --> { I/O }--> |
                                       | (Reads I/O, acks)
                      | <-- { A } ---- |
(Gets expected 'A')   |
                                                        | (wakes up by signal)
(Restarts CPU)        | --- { C } ---> | <--- { . } --- | (sends byte, stops)
                                       | (Reads 'C', will ignore)
(Reads '.')	      |
(Go to console mode)  |
		      |
		      v


[1] http://homepage.cs.uiowa.edu/~jones/pdp8/man/index.html
[2] http://bitsavers.informatik.uni-stuttgart.de/pdf/dec/pdp8/handbooks/Small_Computer_Handbook_1973.pdf
[3] http://www.ultimate.com/phil/xy/
[4] http://homepage.cs.uiowa.edu/~jones/pdp8/emulator.txt.Z
[5] http://jeelabs.org/2016/10/stm32f103-emulating-a-pdp-8/
[6] http://bitsavers.informatik.uni-stuttgart.de/pdf/dec/pdp8/os8/DEC-S8-OSHBA-A_DN4_OS8_Handbook_Update_Sep77.pdf
[7] http://bitsavers.informatik.uni-stuttgart.de/pdf/dec/disc/rx01/EK-RX01-MM-002_maint_Dec76.pdf